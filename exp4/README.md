# 实验五：简单文件系统的实现
## * 设计目的
* 略
## * 内容要求
### * 0x00
* 在内存中开辟一个虚拟磁盘空间作为文件存储分区，在其上实现一个简单的基于多级目录的单用户单任务系统中的文件系统。在退出该文件系统的使用时，应将该虚拟文件系统以一个文件的方式保存到磁盘上，以便下次可以再将它恢复到内存的虚拟磁盘空间中。  

### * 0x01
* 文件存储空间的分配可采用显式链接分配或其他的办法。  

### * 0x02
* 空闲磁盘空间的管理可选择位示图或其他的办法。如果采用位示图来管理文件存储空间，并采用显式链接分配方式，那么可以将位示图合并到 FAT 中。  

### * 0x03
* 文件目录结构采用多级目录结构。为了简单起见，可以不使用索引结点，其中的每个目录项应包含文件名、物理地址、长度等信息，还可以通过目录项实现对文件的读和写的保护。  

### * 0x04
* 要求提供以下操作命令：  

- my_format：对文件存储器进行格式化，即按照文件系统的结构对虚拟磁盘空间进行布局，并在其上创建根目录以及用于管理文件存储空间等的数据结构。
- my_mkdir：用于创建子目录。
- my_rmdir：用于删除子目录。
- my_ls：用于显示目录中的内容。
- my_cd：用于更改当前目录。
- my_create：用于创建文件。
- my_open：用于打开文件。
- my_close：用于关闭文件。
- my_write：用于写文件。
- my_read：用于读文件。
- my_rm：用于删除文件。
- my_exitsys：用于退出文件系统  

## 实例主要命令及函数设计  

### 1．系统主函数main()  
（1）对应命令：无  
（2）命令调用格式：无  
（3）函数设计格式：int main()  
（4）功能：系统主函数  
（5）输入：无  
（6）输出：无  
（7）函数需完成的工作：  
① 对前面定义的全局变量进行初始化；  
② 调用startsys()进入文件系统；  
③ 列出文件系统提供的各项功能及命令调用格式；  
④ 显示命令行提示符，等待用户输入命令；  
⑤ 将用户输入的命令保存到一个buf 中；  
⑥ 对buf 中的内容进行命令解析，并调用相应的函数执行用户键入的命令；  
⑦ 如果命令不是“my_exitsys”，则命令执行完毕后转④。    

### 2. 进入文件系统函数startsys()  
（1）对应命令：无  
（2）命令调用格式：无  
（3）函数设计格式：void startsys()  
（4）功能：由main()函数调用，进入并初始化我们所建立的文件系统，以供用户使用。  
（5）输入：无  
（6）输出：无。  
（7）函数需完成的工作：  
① 申请虚拟磁盘空间；  
② 使用c语言的库函数fopen()打开myfsys文件：若文件存在，则转③；若文件不存在，则创建之，转⑤  
③ 使用c语言的库函数fread()读入myfsys文件内容到用户空间中的一个缓冲区中，并判断其开始的8个字节内容是否为“10101010”（文件系统魔数），如果是，则转④；否则转⑤；  
④ 将上述缓冲区中的内容复制到内存中的虚拟磁盘空间中；转⑦  
⑤ 在屏幕上显示“myfsys文件系统不存在，现在开始创建文件系统”信息，并调用my_format()对①中申请到的虚拟磁盘空间进行格式化操作。转⑥；  
⑥ 将虚拟磁盘中的内容保存到myfsys文件中；转⑦  
⑦ 使用c语言的库函数fclose()关闭myfsys文件；  
⑧ 初始化用户打开文件表，将表项0分配给根目录文件使用，并填写根目录文件的相关信息，由于根目录没有上级目录，所以表项中的dirno和diroff分别置为5（根目录所在起始块号）和0；并将ptrcurdir指针指向该用户打开文件表项。  
⑨ 将当前目录设置为根目录。  

### 3．磁盘格式化函数my_format()  
（1）对应命令：format  
（2）命令调用格式：format  
（3）函数设计格式：void my_format()  
（4）功能：对虚拟磁盘进行格式化，布局虚拟磁盘，建立根目录文件（或根目录区）。  
（5）输入：无  
（6）输出：无。  
（7）函数需完成的工作：  
① 将虚拟磁盘第一个块作为引导块，开始的8个字节是文件系统的魔数，记为“10101010”；在之后写入文件系统的描述信息，如FAT表大小及位置、根目录大小及位置、盘块大小、盘块数量、数据区开始位置等信息；  
② 在引导块后建立两张完全一样的FAT表，用于记录文件所占据的磁盘块及管理虚拟磁盘块的分配，每个FAT占据两个磁盘块；对于每个FAT中，前面5个块设置为已分配，后面995个块设置为空闲；  
③ 在第二张FAT后创建根目录文件root，将数据区的第1块（即虚拟磁盘的第6块）分配给根目录文件，在该磁盘上创建两个特殊的目录项：“.”和“..”，其内容除了文件名不同之外，其他字段完全相同。  

### 4．更改当前目录函数my_cd()  
（1）对应命令：cd  
（2）命令调用格式：cd dirname  
（3）函数设计格式：void my_cd(char *dirname)  
（4）功能：改变当前目录到指定的名为dirname的目录。  
（5）输入：dirname：新的当前目录的目录名；  
（6）输出：无  
（7）函数需完成的工作：  
① 调用my_open()打开指定目录名的父目录文件，并调用do_read()读入该父目录文件内容到内存中；  
② 在父目录文件中检查新的当前目录名是否存在，如果存在则转③，否则返回，并显示出错信息；  
③ 调用my_close()关闭①中打开的父目录文件；  
④ 调用my_close()关闭原当前目录文件；  
⑤ 如果新的当前目录文件没有打开，则打开该目录文件；并将ptrcurdir指向该打开文件表项；  
⑥ 设置当前目录为该目录。  

### 5．创建子目录函数my_mkdir()  
（1）对应命令：mkdir  
（2）命令调用格式：mkdir dirname  
（3）函数设计格式：void my_mkdir(char *dirname)   
（4）功能：在当前目录下创建名为dirname的子目录。  
（5）输入：dirname：新建目录的目录名。  
（6）输出：无。  
（7）函数需完成的工作：  
① 调用do_read()读入当前目录文件内容到内存，检查当前目录下新建目录文件是否重名，若重名则返回，并显示错误信息；  
② 为新建子目录文件分配一个空闲打开文件表项，如果没有空闲表项则返回-1，并显示错误信息；  
③ 检查FAT是否有空闲的盘块，如有则为新建目录文件分配一个盘块，否则释放①中分配的打开文件表项，返回，并显示错误信息；  
④ 在当前目录中为新建目录文件寻找一个空闲的目录项或为其追加一个新的目录项;需修改当前目录文件的长度信息，并将当前目录文件的用户打开文件表项中的fcbstate置为1；  
⑤ 准备好新建目录文件的FCB的内容，文件的属性为目录文件，以覆盖写方式调用do_write()将其填写到对应的空目录项中；  
⑥ 在新建目录文件所分配到的磁盘块中建立两个特殊的目录项“.”和“..”目录项，方法是：首先在用户空间中准备好内容，然后以截断写或者覆盖写方式调用do_write()将其写到③中分配到的磁盘块中；  
⑦ 返回。   

### 6．删除子目录函数rmdir()  
（1）对应命令：rmdir  
（2）命令调用格式：rmdir dirname  
（1）函数设计格式：void my_rmdir(char *dirname)  
（2）功能：在当前目录下删除名为dirname的子目录。  
（3）输入：dirname：欲删除目录的目录名。  
（4）输出：无。  
（5）函数需完成的工作：  
① 调用do_read()读入当前目录文件内容到内存，检查当前目录下欲删除目录文件是否存在，若不存在则返回，并显示错误信息；  
② 检查欲删除目录文件是否为空（除了“.”和“..”外没有其他子目录和文件），可根据其目录项中记录的文件长度来判断，若不为空则返回，并显示错误信息；  
③ 检查该目录文件是否已经打开，若已打开则调用my_close()关闭掉；  
④ 回收该目录文件所占据的磁盘块，修改FAT；  
⑤ 从当前目录文件中清空该目录文件的目录项，且free字段置为0：以覆盖写方式调用do_write()来实现；  
⑥ 修改当前目录文件的用户打开表项中的长度信息，并将表项中的fcbstate置为1；  
⑦ 返回。  

### 7．显示目录函数my_ls()  
（1）对应命令：ls  
（2）命令调用格式：ls  
（3）函数设计格式：void my_ls(void)  
（4）功能：显示当前目录的内容（子目录和文件信息）。  
（5）输入：无  
（6）输出：无  
（7）函数需完成的工作：  
① 调用do_read()读出当前目录文件内容到内存；  
② 将读出的目录文件的信息按照一定的格式显示到屏幕上；  
③ 返回。  

### 8．创建文件函数my_create()  
（1）对应命令：create  
（2）命令调用格式：create filename  
（3）函数设计格式：int my_create (char *filename)  
（4）功能：创建名为filename的新文件。  
（5）输入：filename：新建文件的文件名，可能包含路径。  
（6）输出：若创建成功，返回该文件的文件描述符（文件打开表中的数组下标）；否则返回-1。  
（7）函数需完成的工作：  
① 为新文件分配一个空闲打开文件表项，如果没有空闲表项则返回-1，并显示错误信息；  
② 若新文件的父目录文件还没有打开，则调用my_open()打开；若打开失败，则释放①中为新建文件分配的空闲文件打开表项，返回-1，并显示错误信息；  
③ 调用do_read()读出该父目录文件内容到内存，检查该目录下新文件是否重名，若重名则释放①中分配的打开文件表项，并调用my_close()关闭②中打开的目录文件；然后返回-1，并显示错误信息；  
④ 检查FAT是否有空闲的盘块，如有则为新文件分配一个盘块，否则释放①中分配的打开文件表项，并调用my_close()关闭②中打开的目录文件；返回-1，并显示错误信息；  
⑤ 在父目录中为新文件寻找一个空闲的目录项或为其追加一个新的目录项;需修改该目录文件的长度信息，并将该目录文件的用户打开文件表项中的fcbstate置为1；  
⑥ 准备好新文件的FCB的内容，文件的属性为数据文件，长度为0，以覆盖写方式调用do_write()将其填写到⑤中分配到的空目录项中；  
⑦ 为新文件填写①中分配到的空闲打开文件表项，fcbstate字段值为0，读写指针值为0；  
⑧ 调用my_close()关闭②中打开的父目录文件；  
⑨ 将新文件的打开文件表项序号作为其文件描述符返回。  

### 9．删除文件函数my_rm()  
（1）对应命令：rm  
（2）命令调用格式：rm filename  
（3）函数设计格式：void my_rm(char *filename)  
（4）功能：删除名为filename的文件。  
（5）输入：filename：欲删除文件的文件名，可能还包含路径。  
（6）输出：无。  
（7）函数需完成的工作：  
① 若欲删除文件的父目录文件还没有打开，则调用my_open()打开；若打开失败，则返回，并显示错误信息；  
② 调用do_read()读出该父目录文件内容到内存，检查该目录下欲删除文件是否存在，若不存在则返回，并显示错误信息；  
③ 检查该文件是否已经打开，若已打开则关闭掉；  
④ 回收该文件所占据的磁盘块，修改FAT；  
⑤ 从文件的父目录文件中清空该文件的目录项，且free字段置为0：以覆盖写方式调用do_write()来实现；  
⑥ 修改该父目录文件的用户打开文件表项中的长度信息，并将该表项中的fcbstate置为1；  
⑦ 返回。  

### 10．打开文件函数my_open()  
（1）对应命令：open  
（2）命令调用格式：open filename  
（3）函数设计格式：int my_open(char *filename)  
（4）功能：打开当前目录下名为filename的文件。  
（5）输入：filename：欲打开文件的文件名  
（6）输出：若打开成功，返回该文件的描述符（在用户打开文件表中表项序号）；否则返回-1。  
（7）函数需完成的工作：  
① 检查该文件是否已经打开，若已打开则返回-1，并显示错误信息；  
② 调用do_read()读出父目录文件的内容到内存，检查该目录下欲打开文件是否存在，若不存在则返回-1，并显示错误信息；  
③ 检查用户打开文件表中是否有空表项，若有则为欲打开文件分配一个空表项，若没有则返回-1，并显示错误信息；  
④ 为该文件填写空白用户打开文件表表项内容，读写指针置为0；  
⑤ 将该文件所分配到的空白用户打开文件表表项序号（数组下标）作为文件描述符fd返回。  

### 11．关闭文件函数my_close()  
（1）对应命令：close  
（2）命令调用格式：close fd  
（3）函数设计格式：void my_close(int fd)  
（4）功能：关闭前面由my_open()打开的文件描述符为fd的文件。  
（5）输入：fd：文件描述符。  
（6）输出：无。  
（7）函数需完成的工作：  
① 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1；  
② 检查用户打开文件表表项中的fcbstate字段的值，如果为1则需要将该文件的FCB的内容保存到虚拟磁盘上该文件的目录项中，方法是：打开该文件的父目录文件，以覆盖写方式调用do_write()将欲关闭文件的FCB写入父目录文件的相应盘块中；  
③ 回收该文件占据的用户打开文件表表项（进行清空操作），并将topenfile字段置为0；  
④ 返回。  

### 12．写文件函数my_write()  
（1）对应命令：write  
（2）命令调用格式：write fd  
（3）函数设计格式：int my_write(int fd)  
（4）功能：将用户通过键盘输入的内容写到fd所指定的文件中。磁盘文件的读写操作都必须以完整的数据块为单位进行，在写操作时，先将数据写在缓冲区中，缓冲区的大小与磁盘块的大小相同，然后再将缓冲区中的数据一次性写到磁盘块中；读出时先将一个磁盘块中的内容读到缓冲区中，然后再传送到用户区。本实例为了简便起见，没有设置缓冲区管理，只是在读写文件时由用户使用malloc()申请一块空间作为缓冲区，读写操作结束后使用free()释放掉。  
写操作常有三种方式：截断写、覆盖写和追加写。截断写是放弃原来文件的内容，重新写文件；覆盖写是修改文件在当前读写指针所指的位置开始的部分内容；追加写是在原文件的最后添加新的内容。在本实例中，输入写文件命令后，系统会出现提示让用户选择其中的一种写方式，并将随后键盘输入的内容按照所选的方式写到文件中，键盘输入内容通过CTR+Z键（或其他设定的键）结束。  
（5）输入：fd:open()函数的返回值，文件的描述符；  
（6）输出：实际写入的字节数。  
（7）函数需完成的工作：  
① 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1，并显示出错信息；  
② 提示并等待用户输入写方式：（1：截断写；2：覆盖写；3：追加写）  
③ 如果用户要求的写方式是截断写，则释放文件除第一块外的其他磁盘空间内容（查找并修改FAT表），将内存用户打开文件表项中文件长度修改为0，将读写指针置为0并转④；如果用户要求的写方式是追加写，则修改文件的当前读写指针位置到文件的末尾，并转④；如果写方式是覆盖写，则直接转④；  
④ 提示用户：整个输入内容通过CTR+Z键（或其他设定的键）结束；用户可分多次输入写入内容，每次用回车结束；  
⑤ 等待用户从键盘输入文件内容，并将用户的本次输入内容保存到一临时变量text[]中，要求每次输入以回车结束，全部结束用CTR+Z键（或其他设定的键）；  
⑥ 调用do_write()函数将通过键盘键入的内容写到文件中。  
⑦ 如果do_write()函数的返回值为非负值，则将实际写入字节数增加do_write()函数返回值，否则显示出错信息，并转⑨；  
⑧ 如果text[]中最后一个字符不是结束字符CTR+Z，则转⑦继续进行写操作；否则转⑨；  
⑨ 如果当前读写指针位置大于用户打开文件表项中的文件长度，则修改打开文件表项中的文件长度信息，并将fcbstate置1；  
⑩ 返回实际写入的字节数。  

### 13．实际写文件函数do_write()  
（1）对应命令：无  
（2）命令调用格式：无  
（3）函数设计格式：int my_write(int fd，char *text，int len，char wstyle)  
（4）功能：被写文件函数my_write()调用，用来将键盘输入的内容写到相应的文件中去。  
（5）输入：fd：open()函数的返回值，文件的描述符；  
text：指向要写入的内容的指针；  
len：本次要求写入字节数  
wstyle：写方式  
（6）输出：实际写入的字节数。  
（7）函数需完成的工作：  
① 用malloc()申请1024B的内存空间作为读写磁盘的缓冲区buf，申请失败则返回-1，并显示出错信息；
② 将读写指针转化为逻辑块块号和块内偏移off，并利用打开文件表表项中的首块号及FAT表的相关内容将逻辑块块号转换成对应的磁盘块块号blkno；如果找不到对应的磁盘块，则需要检索FAT为该逻辑块分配一新的磁盘块，并将对应的磁盘块块号blkno登记到FAT中，若分配失败，则返回-1，并显示出错信息；  
③ 如果是覆盖写，或者如果当前读写指针所对应的块内偏移off不等于0，则将块号为blkno的虚拟磁盘块全部1024B的内容读到缓冲区buf中；否则便用ASCII码0清空buf；  
④ 将text中未写入的内容暂存到缓冲区buff的第off字节开始的位置，直到缓冲区满，或者接收到结束字符CTR+Z为止；将本次写入字节数记录到tmplen中；  
⑤ 将buf中1024B的内容写入到块号为blkno的虚拟磁盘块中；  
⑥将当前读写指针修改为原来的值加上tmplen；并将本次实际写入的字节数增加tmplen；  
⑦ 如果tmplen小于len，则转②继续写入；否则转⑧；  
⑧ 返回本次实际写入的字节数。  

### 14．读文件函数my_read()  
（1）对应命令：read  
（2）命令调用格式：read fd len  
（3）函数设计格式：int myread (int fd, int len)  
（4）功能：读出指定文件中从读写指针开始的长度为len的内容到用户空间中。  
（5）输入：  
fd： open()函数的返回值，文件的描述符；  
len: 要从文件中读出的字节数。  
（6）输出：实际读出的字节数。  
（7）函数需完成的工作：  
① 定义一个字符型数组text[len]，用来接收用户从文件中读出的文件内容；  
② 检查fd的有效性（fd不能超出用户打开文件表所在数组的最大下标），如果无效则返回-1，并显示出错信息；  
③ 调用do_read()将指定文件中的len字节内容读出到text[]中；  
④ 如果do_read()的返回值为负，则显示出错信息；否则将text[]中的内容显示到屏幕上；  
⑤ 返回。    

### 15．实际读文件函数do_read()  
（1）对应命令：无  
（2）命令调用格式：无  
（3）函数设计格式：int do_read (int fd, int len,char *text)  
（4）功能：被my_read()调用，读出指定文件中从读写指针开始的长度为len的内容到用户空间的text中。  
（5）输入：  
fd： open()函数的返回值，文件的描述符；  
len: 要求从文件中读出的字节数。  
text：指向存放读出数据的用户区地址  
（6）输出：实际读出的字节数。  
（7）函数需完成的工作：  
① 使用malloc()申请1024B空间作为缓冲区buf，申请失败则返回-1，并显示出错信息；  
② 将读写指针转化为逻辑块块号及块内偏移量off，利用打开文件表表项中的首块号查找FAT表，找到该逻辑块所在的磁盘块块号；将该磁盘块块号转化为虚拟磁盘上的内存位置；  
③ 将该内存位置开始的1024B（一个磁盘块）内容读入buf中；  
④ 比较buf中从偏移量off开始的剩余字节数是否大于等于应读写的字节数len，如果是，则将从off开始的buf中的len长度的内容读入到text[]中；否则，将从off开始的buf中的剩余内容读入到text[]中；  
⑤ 将读写指针增加④中已读字节数，将应读写的字节数len减去④中已读字节数，若len大于0，则转②；否则转⑥；  
⑥ 使用free()释放①中申请的buf。  
⑦ 返回实际读出的字节数。    

### 16. 退出文件系统函数my_exitsys()  
（1）对应命令：exit  
（2）命令调用格式：exit  
（1）函数设计格式：void my_exitsys()  
（2）功能：退出文件系统。  
（3）输入：无  
（4）输出：无。  
（5）函数需完成的工作：  
① 使用C库函数fopen()打开磁盘上的myfsys文件；  
② 将虚拟磁盘空间中的所有内容保存到磁盘上的myfsys文件中；  
③ 使用c语言的库函数fclose()关闭myfsys文件；  
④ 撤销用户打开文件表，释放其内存空间  
④ 释放虚拟磁盘空间。  
